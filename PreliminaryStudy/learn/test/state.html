<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="../js/react.development.js"></script>
    <script src="../js/react-dom.development.js"></script>
    <script src="../js/babel.min.js"></script>
</head>
<body>
    <!-- React 把组件看成是一个状态机（State Machines）。通过与用户的交互，实现不同状态，然后渲染 UI，让用户界面和数据保持一致。React 里，只需更新组件的 state，然后根据新的 state 重新渲染用户界面（不要操作 DOM）。 -->
    <div id="example"></div>
    <script type="text/babel">
        // class Clock extends React.Component {
        //     constructor(props) {
        //         super(props);
        //         this.state = {date: new Date()};
        //     }
        //     render() {
        //         return (
        //             <div>
        //                 <h1>Hello, world!</h1>
        //                 <h2>现在是{this.state.date.toLocaleTimeString()}</h2>
        //             </div>
        //         );
        //     }
        // }
        // ReactDOM.render(
        //     <Clock />,
        //     document.getElementById('example')
        // )


        // 1.将生命周期方法添加到类中
        // class Clcok extends React.Component {
        //     constructor(props) {
        //         super(props);
        //         this.state = {date: new Date()};
        //     }
        //     componentDidMount() {
        //         this.timeID = setInterval(
        //             () => this.tick(), 1000
        //         );
        //     }
        //     componentWillUnmount() {
        //         clearInterval(this.timeID);
        //     }
        //     tick() {
        //         this.setState({
        //             date: new Date()
        //         });
        //     }
        //     render() {
        //         return (
        //             <div>
        //                 <h1>Hello, wolrd</h1>
        //                 <h2>现在是{this.state.date.toLocaleTimeString()}</h2>    
        //             </div>
        //         );
        //     }
        // } 
        // ReactDOM.render(
        //     <Clcok />,
        //     document.getElementById('example')
        // )
        // // componentDidMount() 与 componentWillUnmount() 方法被称作生命周期钩子。


        // 2.数据自顶向下流动
        // 父组件或子组件都不能知道某个组件是有状态还是无状态，并且它们不应该关心某组件是被定义为一个函数还是一个类。
        // 这就是为什么状态通常被称为局部或封装。 除了拥有并设置它的组件外，其它组件不可访问。

        // function FormattedDate(props) {
        //     return <h2>现在是{props.date.toLocaleTimeString()}</h2>
        // }
        // class Cloak extends React.Component {
        //     constructor(props) {
        //         super(props);
        //         this.state = {date: new Date()};
        //     }
        //     componentDidMount() {
        //         this.timerID = setInterval(() => this.tick(), 1000);
        //     }
        //     componentWillUnmount() {
        //         clearInterval(this.timerID);
        //     }
        //     tick() {
        //         this.setState({
        //             date: new Date()
        //         });
        //     }
        //     render() {
        //         return (
        //             <div>
        //                 <h1>Hello, world</h1>
        //                 <FormattedDate date={this.state.date} />     
        //             </div>
        //         );
        //     }
        // }
        // ReactDOM.render(
        //     <Cloak />,
        //     document.getElementById('example')
        // )
        // // 这通常被称为自顶向下或单向数据流。 任何状态始终由某些特定组件所有，并且从该状态导出的任何数据或 UI 只能影响树中下方的组件。
        // // 如果你想象一个组件树作为属性的瀑布，每个组件的状态就像一个额外的水源，它连接在一个任意点，但也流下来。

        function FormattedDate(props) {
            return <h2>现在是{props.date.toLocaleTimeString()}</h2>;
        }
        class Cloak extends React.Component {
            constructor(props) {
                super(props);
                this.state = {date: new Date()};
            }
            componentDidMount() {
                this.timeID = setInterval(() => this.tick(), 1000);
            }
            componentWillUnmount() {
                clearInterval(this.timeID);
            }
            tick() {
                this.setState({
                    date: new Date()
                })
            }
            render() {
                return (
                    <div>
                        <h1>Hello, world</h1>
                        <FormattedDate date={this.state.date} />
                    </div>
                );
            }
        }
        function App() {
            return (
                <div>
                    <Cloak />
                    <Cloak />
                    <Cloak />
                </div>
            );
        }
        ReactDOM.render(
            <App />,
            document.getElementById('example')
        )
    </script>
</body>
</html>